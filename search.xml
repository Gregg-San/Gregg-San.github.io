<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Python-排序算法]]></title>
    <url>%2F2019%2F09%2F28%2FPython-%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%2F</url>
    <content type="text"><![CDATA[顺序查找（Sequence Search）顺序查找是按照序列原有顺序对数组进行遍历比较查询的基本查找算法。123456def seq_search(items, elem): """顺序查找""" for index, item in enumerate(items): if item == elem: return index return -1 二分查找/折半查找（Binary Search）二分查找是一种效率较高的查找方法。但是，折半查找要求线性表必须采用顺序存储结构，而且表中元素按关键字有序排列。 12345678910def bin_search(items, elem): """折半查找(二分查找)""" start, end = 0, len(items) - 1 while start &lt;= end: mid = (start + end) // 2 if elem &lt; items[mid]: end = mid - 1 elif elem &gt; items[mid]: start = mid + 1 else: return mid return -1 冒泡排序（Bubble Sort）冒泡排序是一种计算机科学领域的较简单的排序算法。它重复地走访过要排序的元素列，依次比较两个相邻的元素，如果他们的顺序（如从大到小、首字母从A到Z）错误就把他们交换过来。走访元素的工作是重复地进行直到没有相邻元素需要交换，也就是说该元素已经排序完成。 1234567891011121314151617181920# 实现排序自定义，避免极端情况，正向逆向都比较一次def bubble_sort(origin_items, *, comp=lambda x, y: x &gt; y): """冒泡排序""" items = origin_items[:] length = len(items) for i in range(1, length): swapped = False for j in range(0, length - i): if comp(items[j], items[j + 1]): items[j], items[j + 1] = items[j + 1], items[j] swapped = True if swapped: swapped = False for j in range(length - i - 1, i - 1, -1): if comp(items[j - 1], items[j]): items[j - 1], items[j] = items[j], items[j - 1] swapped = True if not swapped: break return items 归并排序（Merge Sort）归并排序是建立在归并操作上的一种有效的排序算法,该算法是采用分治法（Divide and Conquer）的一个非常典型的应用。将已有序的子序列合并，得到完全有序的序列；即先使每个子序列有序，再使子序列段间有序。若将两个有序表合并成一个有序表，称为二路归并。 123456789101112131415161718192021222324def merge(list1, list2, comp=lambda x, y: x &lt;= y): """"有序合并(将两个有序的列表合并成一个新的有序的列表)""" list3 = [] index1, index2 = 0, 0 while index1 &lt; len(list1) and index2 &lt; len(list2): if comp(list1[index1], list2[index2]): list3.append(list1[index1]) index1 += 1 else: list3.append(list2[index2]) index2 += 1 list3 += list1[index1:] list3 += list2[index2:] return list3def merge_sort(origin_items, comp=lambda x, y: x &lt;= y): """归并排序""" if len(origin_items) &lt; 2: return origin_items[:] mid = len(origin_items) // 2 left = merge_sort(origin_items[:mid], comp) right = merge_sort(origin_items[mid:], comp) return merge(left, right, comp)]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>Algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python–zlib/hashlib/rsa]]></title>
    <url>%2F2019%2F09%2F28%2FPython%E2%80%93zlib-hashlib-rsa%2F</url>
    <content type="text"><![CDATA[zlib-数据压缩解压缩库123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566import zlibimport requestsdef save_to_file(data): with open('begin_file.txt', 'wb') as f: f.write(data)# zlib.compress 用来压缩字符串的bytes类型def str_zlib(): response = requests.get("https://www.baidu.com") message = response.text bytes_message = str.encode(message) save_to_file(bytes_message) compressed = zlib.compress(bytes_message, zlib.Z_BEST_COMPRESSION) decompressed = zlib.decompress(compressed) print("original string:", len(message)) print("original bytes:", len(bytes_message)) print("compressed:", len(compressed)) print("decompressed:", len(decompressed))# zlib.compressobj 用来压缩数据流，用于文件传输def file_compress(begin_file, zlib_file, level): infile = open(begin_file, "rb") zfile = open(zlib_file, "wb") compressobj = zlib.compressobj(level) data = infile.read(1024) while data: zfile.write(compressobj.compress(data)) # 继续读取文件中的下一个size的内容 data = infile.read(1024) # compressobj.flush()包含剩余压缩输出的字节对象，将剩余的字节内容写入到目标文件中 zfile.write(compressobj.flush())def file_decompress(zlib_file, end_file): zlib_file = open(zlib_file, "rb") end_file = open(end_file, "wb") decompressobj = zlib.decompressobj() data = zlib_file.read(1024) while data: end_file.write(decompressobj.decompress(data)) data = zlib_file.read(1024) end_file.write(decompressobj.flush())def main(): # 测试字符串的压缩与解压 str_zlib() # 测试数据流压缩 begin_file = "./begin_file.txt" zlib_file = "./zlib_file.txt" level = 9 file_compress(begin_file, zlib_file, level) # 测试数据流解压 zlib_file = "./zlib_file.txt" end_file = "./end_file.txt" file_decompress(zlib_file, end_file)if __name__ == "__main__": main() hashlib-哈希摘要生成器1234567891011121314151617181920212223242526272829303132333435363738394041424344from hashlib import md5from hashlib import sha1from hashlib import sha256from hashlib import sha512class StreamHasher(): """哈希摘要生成器""" def __init__(self, algorithm='md5', size=1024): self.size = size alg = algorithm.lower() if alg == 'md5': self.hasher = md5() elif alg == 'sha1': self.hasher = sha1() elif alg == 'sha256': self.hasher = sha256() elif alg == 'sha512': self.hasher = sha512() else: raise ValueError('不支持指定的摘要算法') # 魔法方法: 让对象可以像函数一样被调用 def __call__(self, stream): return self.to_digest(stream) def to_digest(self, stream): """生成十六进制形式的哈希摘要字符串""" for data in iter(lambda: stream.read(self.size), b''): self.hasher.update(data) return self.hasher.hexdigest()def main(): """主函数""" hasher = StreamHasher('sha1', 4096) with open('Python魔法方法指南.pdf', 'rb') as stream: # print(hasher.to_digest(stream)) print(hasher(stream))if __name__ == '__main__': main() rsa-加密库12345678910111213141516171819202122232425262728293031323334353637import rsa# 生成密钥(pubkey, privkey) = rsa.newkeys(1024)# 保存密钥with open('public.pem', 'w+') as f: f.write(pubkey.save_pkcs1().decode())with open('private.pem', 'w+') as f: f.write(privkey.save_pkcs1().decode())# 导入密钥with open('public.pem', 'r') as f: pubkey = rsa.PublicKey.load_pkcs1(f.read().encode())with open('private.pem', 'r') as f: privkey = rsa.PrivateKey.load_pkcs1(f.read().encode())# 明文message = 'zhezhendeshiyigemima'# 公钥加密crypto = rsa.encrypt(message.encode(), pubkey)print(crypto)# 私钥解密message = rsa.decrypt(crypto, privkey).decode()print(message)# 私钥签名signature = rsa.sign(message.encode(), privkey, 'SHA-1')print(signature)# 公钥验证result = rsa.verify(message.encode(), signature, pubkey)print(result)]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>Algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Windows Server 2012 R2 FTP Server]]></title>
    <url>%2F2019%2F09%2F28%2FWindows-Server-2012-R2-FTP-Server%2F</url>
    <content type="text"><![CDATA[打开Windows Server 2012 R2 服务器管理器界面 添加角色和功能添加角色和功能向导里，选择 从服务器池中选择服务器选择Web 服务器（IIS）安装 FTP服务器安装完成后，在服务器管理器右上角有个点击 “工具”–&gt;选择“IIS管理器”点击IIS 服务器证书FTP界面上选择“FTP身份验证”——&gt;“基本身份验证”–&gt;”启用” FTP界面选择 “FTP授权规则“—&gt;右侧“添加允许规则”–&gt;选择“指定的角色或用户组”,以及权限选择，“读取 写入 完成所有前戏后，接下来就开始进行建立FTP网站，点击IIS管理器界面 “网站”，点击右侧添加“FTP站点”，FTP站点名称可以任意取，内容目录为服务器上提供上传、下载文件保存目录。 点击“下一步”绑定IP可以选取指定IP，也可以默认，端口号默认21，勾选下面“自动启动FTP站点”导入刚才建立的SSL证书 点击“下一步”身份验证和授权信息配置 配置完成（浏览器和FTP客户端软件上登陆） 123ftp://ip# 提示输入账户密码]]></content>
      <categories>
        <category>Windows</category>
      </categories>
      <tags>
        <tag>FTP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Golang基础语法之二]]></title>
    <url>%2F2019%2F09%2F28%2FGolang%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95%E4%B9%8B%E4%BA%8C%2F</url>
    <content type="text"><![CDATA[输入和输出输出：12345/*Print() // 打印Printf() // 格式化打印Println() // 打印之后换行*/输入：12345678/*fmt.Scanln(&amp;x, &amp;y) 阻塞式fmt.Scanf("%d, %f", &amp;x, &amp;y)reader := bufio.NewReader(os.Stdin)s, _ := reader.ReadString('\n')*/ if语句1234567if 布尔表达式1 &#123; 执行语句&#125; else if 布尔表达式2 &#123; 执行语句&#125; else &#123; 执行语句&#125; if语句其他写法 12345if num := 4; num &gt; 0 &#123; fmt.Println(num)&#125;// 作用域在if语句里面// fmt.Println(num) // undefined: num switch分支语句12345678switch var1 &#123; case val1: ... case val2: ... default: ...&#125; switch其他写法 1234567891011121314151617181920switch &#123; // 直接作用在true上 case true: fmt.Println("true") case false: fmt.Println("false")&#125;switch var1 &#123; case val1, val2, val3: fmt.Println("true") case val4: fmt.Println("false")&#125;switch var1 := "go"; var1 &#123; // 作用域在switch中 case val1, val2, val3: fmt.Println("true") case val4: fmt.Println("false")&#125; fallthrough: 用于穿透switch，会执行该case后面case的内容，fallthrough在case最后一行 for循环123for init; condition; post &#123;&#125; for语句的其他写法 1234567for condition &#123;&#125; // 相当与while循环for &#123;&#125;for key, value := range oldMap &#123; newMap[key] = value&#125; break 跳出循环体 continue 跳出一次循环 goto1234goto label....label:]]></content>
      <categories>
        <category>Golang</category>
      </categories>
      <tags>
        <tag>Golang</tag>
        <tag>Golang Days</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Golang基础语法之一]]></title>
    <url>%2F2019%2F09%2F28%2FGolang%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95%E4%B9%8B%E4%B8%80%2F</url>
    <content type="text"><![CDATA[Start golangHello World123456789package mainimport "fmt"func main() &#123; fmt.Println("Hello World") // Print 不换行 fmt.Print("Go Go Go!!!")&#125; Run12345go rungo buildgo install go help123456789101112131415161718192021go helpThe commands are: bug start a bug report build compile packages and dependencies clean remove object files and cached files doc show documentation for package or symbol env print Go environment information fix update packages to use new APIs fmt gofmt (reformat) package sources generate generate Go files by processing source get add dependencies to current module and install them install compile and install packages and dependencies list list packages or modules mod module maintenance run compile and run Go program test test packages tool run specified go tool version print Go version vet report likely mistakes in packages 变量 静态语言：强类型语言 动态语言：弱类型语言 go语言特性 1234567var num intnum = 3var num2 = 4// 类型推断var name = "string"// 简短定义num := 100 变量必须先定义才能使用。 变量的类型和赋值必须一致。 同一个作用域内，变量名不能冲突。 简短定义方式，左边的变量名至少有一个是新的。 简短定义的方式，不能定义全局变量。 变量的零值。也叫默认值。 变量定义了就要使用否则无法通过编译。 常量123456789101112// 显式类型定义const b string = “abc”// 隐式类型定义const b = “abc”const ( a int = 100 b c string = "go" d e) 一组常量中，如果某个常量没有初始值，默认和上一行一致 iota12345const ( a = iota // 0 b = iota // 1 c = iota // 2) 数据类型基本数据类型： 布尔类型 数值类型 字符串 符合数据类型： array slice map function pointer struct interface channel 运算符 算术运算符 关系运算符 逻辑运算符 — / &amp;&amp; / || / ! / 位运算符 / 按位&amp; / 按位| / 异或^ / 位清空&amp;^ / 左移运算&lt;&lt; / 右移运算 &gt;&gt; / 赋值运算符]]></content>
      <categories>
        <category>Golang</category>
      </categories>
      <tags>
        <tag>Golang</tag>
        <tag>Golang Days</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Automatic Remote Desktop]]></title>
    <url>%2F2019%2F09%2F27%2FAutomatic-Remote-Desktop%2F</url>
    <content type="text"><![CDATA[Based on Windows Server 2012premise remote machine need open winrm service base host need PsExec.exe for start up display bat script12345678910REM Skip popupREG ADD "HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Terminal Server Client" /v AuthenticationLevelOverride /t REG_DWORD /d 0 /fREM Modify group policyREG ADD "HKEY_LOCAL_MACHINE\SOFTWARE\Policies\Microsoft\Windows\CredentialsDelegation\AllowSavedCredentialsWhenNTLMOnly" /v 1 /t RED_SZ /d TERMSRV/* /fREM Update group policygpupdate /forceREM Add login credentialsCMDKEY /add:remote_ip /user:user /pass:passwordREM Remote desktopMSTSC /v:remote_ip:remote_port start the script by command1PsExec.exe \\ip -accepteula -u user -p password -i cmd or use query user find ID 1PsExec.exe \\ip -accepteula -u user -p password -i ID cmd About wmicopen remote desktop service 1wmic /node:"[full machine name]" /USER:"[domain]\[username]" PATH win32_terminalservicesetting WHERE (__Class!="") CALL SetAllowTSConnections 1 use wmic open remote process 1wmic /node:ip /user:"administrator" /password:"password" process call create commandline="command"]]></content>
      <categories>
        <category>Windows</category>
      </categories>
      <tags>
        <tag>PsExec</tag>
        <tag>bat</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2019%2F09%2F27%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1hexo new "My New Post" More info: Writing Run server1hexo server More info: Server Generate static files1hexo generate More info: Generating Deploy to remote sites1hexo deploy More info: Deployment]]></content>
  </entry>
</search>
